<!DOCTYPE HTML>
<html>
<head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
    <title>Tron</title>


    <script src="jquery.1.11.1.js"></script> <!-- 1 - JQUERY -->
    <script src="pixi.dev.js"></script>  <!-- 2 - Pixi -->
    <script src="hammer.js"></script>  <!-- 3 - Hammer -->

    <script src="loader.js"></script>

    <script src="view.js"></script>

</head>


<body id="body">

  <div class="c4">
    <h3>use WASD to drive the blue bike</h3>
    <h3>use IJKL to drive the red bike</h3>
    <h3>a collision will be shown if the bikes collide</h3>

  </div>

<script>

    var arenaWidth = 600;
    var arenaHeight = 600;

    //assign the bike objects to variables so we can move them around after they are initially created/drawn (unlike walls, which can be drawn and left where they are)
    var bike1View;
    var bike2View;

    var collision1View;


    var tronView = new TronView(arenaWidth, arenaHeight);

    //all the methods we'll need to draw will be accessable via the arena object
    var arenaView = tronView.getArena();

    // game timer
    TIME_PER_FRAME = 33;
    var game_loop = setInterval(update, TIME_PER_FRAME);

    // key handlers
    document.addEventListener("keydown", keyDownHandler, false);

    //bike1
    var bike1_x = 60;
    var bike1_y = 60;
    var bike1_color = 0x0000CC;
    var bike1_speed = 7;
    var bike1_direction = "RIGHT";

    bike1View = arenaView.addBike(bike1_x, bike1_y, bike1_color);

    //bike2
    //var bike2_x = 540;
    //var bike2_y = 540;
    var bike2_x = 60;
    var bike2_y = 80;
    var bike2_color = 0xFF0000;
    var bike2_speed = 7;
    var bike2_direction = "RIGHT";

    bike2View = arenaView.addBike(bike2_x, bike2_y, bike2_color);



    //begin animation loop
    requestAnimFrame(animate);

    //run animation loop
    function animate()
    {
        
        //DO OTHER CONTROLLER STUFF HERE  

        //collision animation
        if (collision1View && collision1View.radius > 0)
        {
            collision1View.radius += 4;
            if (collision1View.radius >= 80) collision1View.radius = 0;

            //we can't simply change the radius, the object has to be redrawn to reflect the adjusted radius
            //redraw is a method I wrote, it's not built into the api
            collision1View.redraw();
        }




        requestAnimFrame(animate);
        view_renderer.render(view_stage);     // render the stage
    }


    //moves the bikes based on last direction
    function update()
    {
        // calculate bike movement
        if (bike1_direction == "UP")
            bike1_y -= bike1_speed;  //w
        else if (bike1_direction == "LEFT")
            bike1_x -= bike1_speed;  //a
        else if (bike1_direction == "DOWN")
            bike1_y += bike1_speed;  //s
        else if (bike1_direction == "RIGHT")
            bike1_x += bike1_speed;  //d

        //keep bike in the arena
        if (bike1_x >= arenaWidth) bike1_x = arenaWidth - bike1_speed;
        if (bike1_x < 0) bike1_x = 0;
        if (bike1_y >= arenaHeight) bike1_y = arenaHeight - bike1_speed;
        if (bike1_y < 0) bike1_y = 0;

        //draw wall behind bike
        arenaView.drawWall(bike1View.x, bike1View.y, bike1_x, bike1_y, bike1_color);

        //move the bike
        bike1View.x = bike1_x;
        bike1View.y = bike1_y;



        // calculate bike movment
        if (bike2_direction == "UP")
            bike2_y -= bike2_speed;  
        else if (bike2_direction == "LEFT")
            bike2_x -= bike2_speed;  
        else if (bike2_direction == "DOWN")
            bike2_y += bike2_speed;  
        else if (bike2_direction == "RIGHT")
            bike2_x += bike2_speed;  

         //keep bike in the arena
        if (bike2_x >= arenaWidth) bike2_x = arenaWidth - bike2_speed;
        if (bike2_x < 0) bike2_x = 0;
        if (bike2_y >= arenaHeight) bike2_y = arenaHeight - bike2_speed;
        if (bike2_y < 0) bike2_y = 0;

        //draw wall behind bike
        arenaView.drawWall(bike2View.x, bike2View.y, bike2_x, bike2_y, bike2_color);

        //move the bike
        bike2View.x = bike2_x;
        bike2View.y = bike2_y;


        //draw collision when bikes hit eachother
        if (bike1View.x == bike2View.x && bike1View.y == bike2View.y)
        {
            collision1View = arenaView.addCollision(bike1View.x, bike1View.y);
            collision1View.radius++;
        }
    }

    function keyDownHandler(event)
    {
        var keyPressed = String.fromCharCode(event.keyCode);

        //for bike1
        if (keyPressed == "W" && bike1_direction != "DOWN")
            bike1_direction = "UP";
        else if (keyPressed == "A" && bike1_direction != "RIGHT")
            bike1_direction = "LEFT";
        else if (keyPressed == "S" && bike1_direction != "UP")          
            bike1_direction = "DOWN";
        else if (keyPressed == "D" && bike1_direction != "LEFT")
            bike1_direction = "RIGHT";

        //for bike2 ijkl
        if (keyPressed == "I" && bike2_direction != "DOWN")
            bike2_direction = "UP";
        else if (keyPressed == "J" && bike2_direction != "RIGHT")
            bike2_direction = "LEFT";
        else if (keyPressed == "K" && bike2_direction != "UP")
            bike2_direction = "DOWN";
        else if (keyPressed == "L" && bike2_direction != "LEFT")
            bike2_direction = "RIGHT";
    }

    //move bike1 up(w), left(a), down(s), right(d)
    //move bike2 up(i), left(j), down(k), right(l)
    //keydown and keypress events fire repeatedly while a key is pressed, but keyup events only fire on a keyup
    //$(document).keyup(function(e){
    //    var key = e.which;

        // console.log("key: " + key);

        

        // console.log("Direction: " + bike1_direction);

        

       
    // });

</script>

</body>

</html>

